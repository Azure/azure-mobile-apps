// Copyright (c) Microsoft Corporation. All Rights Reserved.
// Licensed under the MIT License.

using Microsoft.Datasync.Client.Authentication;
using Microsoft.Datasync.Client.Http;
using Microsoft.Datasync.Client.Offline;
using Microsoft.Datasync.Client.Serialization;
using Microsoft.Datasync.Client.Table;
using Microsoft.Datasync.Client.Utils;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.Datasync.Client
{
    /// <summary>
    /// Provides basic access to a Microsoft Datasync service.
    /// </summary>
    public class DatasyncClient : IDisposable
    {
        /// <summary>
        ///  This is for unit testing only
        /// </summary>
        [ExcludeFromCodeCoverage]
        protected DatasyncClient()
        {
        }

        /// <summary>
        /// Creates a new <see cref="DatasyncClient"/> that connects to the specified endpoint for information transfer.
        /// </summary>
        /// <param name="endpoint">The endpoint of the datasync service.</param>
        /// <exception cref="UriFormatException">if the endpoint is not a valid Uri.</exception>
        public DatasyncClient(string endpoint)
            : this(new Uri(endpoint, UriKind.Absolute), null, null)
        {
        }

        /// <summary>
        /// Creates a new <see cref="DatasyncClient"/> that connects to the specified endpoint for information transfer.
        /// </summary>
        /// <param name="endpoint">The endpoint of the datasync service.</param>
        /// <param name="clientOptions">The client options used to modify any request/response that is sent.</param>
        /// <exception cref="UriFormatException">if the endpoint is not a valid Uri.</exception>
        public DatasyncClient(string endpoint, DatasyncClientOptions clientOptions)
            : this(new Uri(endpoint, UriKind.Absolute), null, clientOptions)
        {
        }

        /// <summary>
        /// Creates a new <see cref="DatasyncClient"/> that connects to the specified endpoint for information transfer.
        /// </summary>
        /// <param name="endpoint">The endpoint of the datasync service.</param>
        /// <param name="authenticationProvider">The authentication provider to use for authenticating the request</param>
        /// <exception cref="UriFormatException">if the endpoint is malformed</exception>
        public DatasyncClient(string endpoint, AuthenticationProvider authenticationProvider)
            : this(new Uri(endpoint, UriKind.Absolute), authenticationProvider, null)
        {
        }

        /// <summary>
        /// Creates a new <see cref="DatasyncClient"/> that connects to the specified endpoint for information transfer.
        /// </summary>
        /// <param name="endpoint">The endpoint of the datasync service.</param>
        /// <param name="authenticationProvider">The authentication provider to use for authenticating the request</param>
        /// <param name="clientOptions">The client options used to modify any request/response that is sent.</param>
        /// <exception cref="UriFormatException">if the endpoint is malformed</exception>
        public DatasyncClient(string endpoint, AuthenticationProvider authenticationProvider, DatasyncClientOptions clientOptions)
            : this(new Uri(endpoint, UriKind.Absolute), authenticationProvider, clientOptions)
        {
        }

        /// <summary>
        /// Creates a new <see cref="DatasyncClient"/> that connects to the specified endpoint for information transfer.
        /// </summary>
        /// <param name="endpoint">The endpoint of the datasync service.</param>
        /// <exception cref="ArgumentNullException">if the endpoint is null</exception>
        /// <exception cref="UriFormatException">if the endpoint is malformed</exception>
        public DatasyncClient(Uri endpoint)
            : this(endpoint, null, null)
        {
        }

        /// <summary>
        /// Creates a new <see cref="DatasyncClient"/> that connects to the specified endpoint for information transfer.
        /// </summary>
        /// <param name="endpoint">The endpoint of the datasync service.</param>
        /// <param name="clientOptions">The client options used to modify any request/response that is sent.</param>
        /// <exception cref="ArgumentNullException">if the endpoint is null</exception>
        /// <exception cref="UriFormatException">if the endpoint is malformed</exception>
        public DatasyncClient(Uri endpoint, DatasyncClientOptions clientOptions)
            : this(endpoint, null, clientOptions)
        {
        }

        /// <summary>
        /// Creates a new <see cref="DatasyncClient"/> that connects to the specified endpoint for information transfer.
        /// </summary>
        /// <param name="endpoint">The endpoint of the datasync service.</param>
        /// <param name="authenticationProvider">The authentication provider to use for authenticating the request</param>
        /// <exception cref="ArgumentNullException">if the endpoint is null</exception>
        /// <exception cref="UriFormatException">if the endpoint is malformed</exception>
        public DatasyncClient(Uri endpoint, AuthenticationProvider authenticationProvider)
            : this(endpoint, authenticationProvider, null)
        {
        }

        /// <summary>
        /// Creates a new <see cref="DatasyncClient"/> that connects to the specified endpoint for information transfer.
        /// </summary>
        /// <param name="endpoint">The endpoint of the datasync service.</param>
        /// <param name="authenticationProvider">The authentication provider to use for authenticating the request</param>
        /// <param name="clientOptions">The client options used to modify any request/response that is sent.</param>
        /// <exception cref="ArgumentNullException">if the endpoint is null</exception>
        /// <exception cref="UriFormatException">if the endpoint is malformed</exception>
        public DatasyncClient(Uri endpoint, AuthenticationProvider authenticationProvider, DatasyncClientOptions clientOptions)
        {
            Arguments.IsValidEndpoint(endpoint, nameof(endpoint));

            Endpoint = endpoint.NormalizeEndpoint();
            ClientOptions = clientOptions ?? new DatasyncClientOptions();
            HttpClient = new ServiceHttpClient(Endpoint, authenticationProvider, ClientOptions);
            if (ClientOptions.SerializerSettings != null)
            {
                Serializer.SerializerSettings = ClientOptions.SerializerSettings;
            }
            if (ClientOptions.OfflineStore != null)
            {
                SyncContext = new SyncContext(this, ClientOptions.OfflineStore);
            }
        }

        /// <summary>
        /// The client options for the service.
        /// </summary>
        public DatasyncClientOptions ClientOptions { get; }

        /// <summary>
        /// Absolute URI of the Microsoft Azure Mobile App.
        /// </summary>
        public Uri Endpoint { get; }

        /// <summary>
        /// Gets the <see cref="ServiceHttpClient"/> associated with the Azure Mobile App.
        /// </summary>
        internal ServiceHttpClient HttpClient { get; }

        /// <summary>
        /// The id used to identify this installation of the application to
        /// provide telemetry data.
        /// </summary>
        public string InstallationId { get => HttpClient.InstallationId; }

        /// <summary>
        /// The number of pending operations, or null if the offline store has not been defined.
        /// </summary>
        public long? PendingOperations { get => SyncContext?.PendingOperations; }

        /// <summary>
        /// The serializer to use for serializing and deserializing content.
        /// </summary>
        public ServiceSerializer Serializer { get; } = new();

        /// <summary>
        /// The synchronization context.
        /// </summary>
        internal SyncContext SyncContext { get; }

        /// <summary>
        /// An event delegate that allows the app to monitor synchronization events.
        /// </summary>
        public event EventHandler<SynchronizationEventArgs> SynchronizationProgress;

        /// <summary>
        /// Returns a reference to an offline table, providing untyped (JSON) data
        /// operations for that table.
        /// </summary>
        /// <param name="tableName">The name of the table.</param>
        /// <returns>A reference to the table.</returns>
        public virtual IOfflineTable GetOfflineTable(string tableName)
        {
            Arguments.IsValidTableName(tableName, nameof(tableName));
            if (SyncContext == null)
            {
                throw new InvalidOperationException("An offline store must be specified before using offline tables.");
            }
            return new OfflineTable(tableName, this);
        }

        /// <summary>
        /// Returns a reference to an offline table, providing typed data
        /// operations for that table.
        /// </summary>
        /// <remarks>
        /// If <paramref name="tableName"/> is not specified, the name of the
        /// type is used as the table name.
        /// </remarks>
        /// <typeparam name="T">The type of the data transfer object (model) being used.</typeparam>
        /// <param name="tableName">The (optional) name of the table.</param>
        /// <returns>A reference to the table.</returns>
        public virtual IOfflineTable<T> GetOfflineTable<T>(string tableName = null)
        {
            tableName ??= Serializer.ResolveTableName<T>();
            Arguments.IsValidTableName(tableName, nameof(tableName));
            if (SyncContext == null)
            {
                throw new InvalidOperationException("An offline store must be specified before using offline tables.");
            }
            if (!SyncContext.OfflineStore.TableIsDefined(tableName))
            {
                SyncContext.OfflineStore.DefineTable<T>(tableName);
            }
            return new OfflineTable<T>(tableName, this);
        }

        /// <summary>
        /// Returns a reference to a remote table, providing untyped (JSON) data
        /// operations for that table.
        /// </summary>
        /// <param name="tableName">The name of the table.</param>
        /// <returns>A reference to the table.</returns>
        public virtual IRemoteTable GetRemoteTable(string tableName)
            => new RemoteTable(tableName, this);

        /// <summary>
        /// Returns a reference to a remote table, providing typed data
        /// operations for that table.
        /// </summary>
        /// <remarks>
        /// If <paramref name="tableName"/> is not specified, the name of the type is used as
        /// the table name.
        /// </remarks>
        /// <typeparam name="T">The type of the data transfer object (model) being used.</typeparam>
        /// <param name="tableName">The (optional) name of the table.</param>
        /// <returns>A reference to the table.</returns>
        public virtual IRemoteTable<T> GetRemoteTable<T>(string tableName = null)
            => new RemoteTable<T>(tableName ?? Serializer.ResolveTableName<T>(), this);

        /// <summary>
        /// Initializes the offline store.
        /// </summary>
        /// <param name="cancellationToken">A <see cref="CancellationToken"/> to observe.</param>
        /// <returns>A task that completes when the offline store is initialized.</returns>
        /// <exception cref="InvalidOperationException">if the offline store was not provided.</exception>
        public virtual async Task InitializeOfflineStoreAsync(CancellationToken cancellationToken = default)
        {
            if (SyncContext == null)
            {
                throw new InvalidOperationException("An offline store must be specified before initialization.");
            }
            await SyncContext.InitializeAsync(cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Pushes the pending operations for all tables to the remote service.
        /// </summary>
        /// <param name="cancellationToken">A <see cref="CancellationToken"/> to observe.</param>
        /// <returns>A task that completes when the pending operations have been pushed.</returns>
        /// <exception cref="InvalidOperationException">if the offline store is not available.</exception>
        public virtual Task PushTablesAsync(CancellationToken cancellationToken = default)
            => PushTablesAsync(Array.Empty<string>(), null, cancellationToken);

        /// <summary>
        /// Pushes the pending operations for all tables to the remote service.
        /// </summary>
        /// <param name="tables">The list of tables to be pushed.</param>
        /// <param name="cancellationToken">A <see cref="CancellationToken"/> to observe.</param>
        /// <returns>A task that completes when the pending operations have been pushed.</returns>
        /// <exception cref="InvalidOperationException">if the offline store is not available.</exception>
        public virtual Task PushTablesAsync(IEnumerable<string> tables, CancellationToken cancellationToken = default)
            => PushTablesAsync(tables, null, cancellationToken);

        /// <summary>
        /// Pushes the pending operations for all tables to the remote service.
        /// </summary>
        /// <param name="options">The push operation options.</param>
        /// <param name="cancellationToken">A <see cref="CancellationToken"/> to observe.</param>
        /// <returns>A task that completes when the pending operations have been pushed.</returns>
        /// <exception cref="InvalidOperationException">if the offline store is not available.</exception>
        public virtual Task PushTablesAsync(PushOptions options, CancellationToken cancellationToken = default)
            => PushTablesAsync(Array.Empty<string>(), options, cancellationToken);

        /// <summary>
        /// Pushes the pending operations for a list of tables to the remote service.  You must name the tables
        /// to be pushed.
        /// </summary>
        /// <param name="tables">The list of tables to be pushed.</param>
        /// <param name="options">The push operation options.</param>
        /// <param name="cancellationToken">A <see cref="CancellationToken"/> to observe.</param>
        /// <returns>A task that completes when the pending operations have been pushed.</returns>
        /// <exception cref="InvalidOperationException">if the offline store is not available.</exception>
        public virtual async Task PushTablesAsync(IEnumerable<string> tables, PushOptions options, CancellationToken cancellationToken = default)
        {
            if (SyncContext == null)
            {
                throw new InvalidOperationException("An offline store must be specified before doing offline operations.");
            }
            await SyncContext.PushItemsAsync(tables.ToArray(), options, cancellationToken).ConfigureAwait(false);
        }

        #region SendAsync
        /// <summary>
        /// Sends a HTTP request to the remote service, using the in-built HTTP client.
        /// </summary>
        /// <param name="request">The HTTP request message to send.</param>
        /// <param name="completionOption">When the operation should complete (as soon as a response is available, or after reading the whole response content).</param>
        /// <param name="cancellationToken">A <see cref="CancellationToken"/> to observe.</param>
        /// <returns>A task that returns the <see cref="HttpResponseMessage"/> for the response when complete.</returns>
        public Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationToken cancellationToken = default)
            => HttpClient.HttpClient.SendAsync(request, completionOption, cancellationToken);

        /// <summary>
        /// Sends a HTTP request to the remote service, using the in-built HTTP client.
        /// </summary>
        /// <param name="request">The HTTP request message to send.</param>
        /// <param name="cancellationToken">A <see cref="CancellationToken"/> to observe.</param>
        /// <returns>A task that returns the <see cref="HttpResponseMessage"/> for the response when complete.</returns>
        public Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken = default)
            => HttpClient.HttpClient.SendAsync(request, cancellationToken);
        #endregion

        /// <summary>
        /// Sends a synchronization event to the consumers.
        /// </summary>
        /// <param name="eventArgs">The event arguments.</param>
        internal void SendSynchronizationEvent(SynchronizationEventArgs eventArgs)
        {
            SynchronizationProgress?.Invoke(this, eventArgs);
        }

        #region IDisposable
        /// <summary>
        /// Implemenation of <see cref="IDisposable"/>
        /// </summary>
        [ExcludeFromCodeCoverage]
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Implemenation of <see cref="IDisposable"/> for
        /// derived classes to use.
        /// </summary>
        /// <param name="disposing">
        /// Indicates if being called from the Dispose() method
        /// or the finalizer.
        /// </param>
        [ExcludeFromCodeCoverage]
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                SyncContext.Dispose();
                HttpClient.Dispose();
            }
        }
        #endregion
    }
}
