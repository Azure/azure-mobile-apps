// Copyright (c) Microsoft Corporation. All Rights Reserved.
// Licensed under the MIT License.

using Microsoft.Datasync.Client.Query.Linq.Nodes;
using Microsoft.Datasync.Client.Serialization;
using Microsoft.Datasync.Client.Utils;
using Newtonsoft.Json.Serialization;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

namespace Microsoft.Datasync.Client.Query.Linq
{
    /// <summary>
    /// Walks the LINQ expression tree to compile the expression into a simplified tree of
    /// nodes that can be used for OData or SQL production.
    /// </summary>
    internal sealed class FilterBuildingExpressionVisitor
    {
        private static readonly MethodInfo concatMethod = typeof(string).GetRuntimeMethod("Concat", new Type[] { typeof(string), typeof(string) });
        private static readonly MethodInfo startsWithMethod = typeof(string).GetRuntimeMethod("StartsWith", new Type[] { typeof(string), typeof(StringComparison) });
        private static readonly MethodInfo endsWithMethod = typeof(string).GetRuntimeMethod("EndsWith", new Type[] { typeof(string), typeof(StringComparison) });
        private static readonly MethodInfo equals1Method = typeof(string).GetRuntimeMethod("Equals", new Type[] { typeof(string) });
        private static readonly MethodInfo equals2Method = typeof(string).GetRuntimeMethod("Equals", new Type[] { typeof(string), typeof(StringComparison) });
        private static readonly MethodInfo toStringMethod = typeof(object).GetTypeInfo().GetDeclaredMethod("ToString");

        /// <summary>
        /// <para>** Do not remove this code. **</para>
        /// </summary>
        /// <remarks>
        /// Some compilers will remove method infos that are never called by an application.
        /// This will break reflection scenarios when the methodInfos searched for via reflection
        /// were not used in the application code and so were removed by the compiler. We search
        /// for the methodInfos for Object.ToString() and String.Concat(string, string) via
        /// reflection, so we need this code here to ensure that don't get removed by the compiler.
        /// </remarks>
        [SuppressMessage("Style", "IDE0059:Unnecessary assignment of a value", Justification = "See code comments - this is required!!!")]
        static FilterBuildingExpressionVisitor()
        {
            string aString = new Object().ToString();
            aString = String.Concat(aString, "a string");
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FilterBuildingExpressionVisitor"/>
        /// </summary>
        /// <param name="contractResolver">The contract resolvers to use to determine property names from members used with expressions.</param>
        internal FilterBuildingExpressionVisitor(DatasyncContractResolver contractResolver) : base()
        {
            Arguments.IsNotNull(contractResolver, nameof(contractResolver));
            ContractResolver = contractResolver;
        }

        /// <summary>
        /// The contract resolvers to use to determine property names from members used with expressions.
        /// </summary>
        internal DatasyncContractResolver ContractResolver { get; }

        /// <summary>
        /// The accumulator for the <see cref="QueryNode"/> being generated by the compiler
        /// </summary>
        internal Stack<QueryNode> FilterExpression { get; } = new Stack<QueryNode>();

        /// <summary>
        /// Translate an expression tree into a compiled OData query.
        /// </summary>
        /// <param name="expression">The expression tree to translate</param>
        /// <param name="contractResolver">The contract resolvers to use to determine property names from members used with expressions.</param>
        /// <returns>An OData <see cref="QueryNode"/></returns>
        internal static QueryNode Compile(Expression expression, DatasyncContractResolver contractResolver)
        {
            var visitor = new FilterBuildingExpressionVisitor(contractResolver);
            visitor.Visit(expression);
            return visitor.FilterExpression.FirstOrDefault();
        }

        /// <summary>
        /// Gets the table member name referenced by an expression, or return null.
        /// </summary>
        /// <param name="expression">The expression to check</param>
        /// <param name="contractResolver">The contract resolvers to use to determine property names from members used with expressions.</param>
        /// <returns>the table member name</returns>
        internal static string GetTableMemberName(Expression expression, DatasyncContractResolver contractResolver)
        {
            Arguments.IsNotNull(expression, nameof(expression));
            Arguments.IsNotNull(contractResolver, nameof(contractResolver));

            if (expression is MemberExpression member)
            {
                if (member.Expression.NodeType == ExpressionType.Parameter)
                {
                    JsonProperty property = contractResolver.ResolveProperty(member.Member);
                    return property.PropertyName;
                }
                if (member.Expression.NodeType == ExpressionType.Convert && member.Member.MemberType == MemberTypes.Property)
                {
                    JsonProperty property = contractResolver.ResolveProperty(member.Member);
                    return property.PropertyName;
                }
            }
            return null;
        }

        /// <summary>
        /// Visits a node of the expression and all sub-nodes, effectively walking the expression tree.
        /// </summary>
        /// <param name="node">The node to visit</param>
        /// <returns>The visited node.</returns>
        internal Expression Visit(Expression node)
        {
            if (node != null)
            {
                // Don't convert to switch expression - this is easier to read.
#pragma warning disable IDE0066 // Convert switch statement to expression
                switch (node.NodeType)
                {
                    case ExpressionType.Add:
                    case ExpressionType.And:
                    case ExpressionType.AndAlso:
                    case ExpressionType.ArrayIndex:
                    case ExpressionType.Coalesce:
                    case ExpressionType.Divide:
                    case ExpressionType.Equal:
                    case ExpressionType.ExclusiveOr:
                    case ExpressionType.GreaterThan:
                    case ExpressionType.GreaterThanOrEqual:
                    case ExpressionType.LeftShift:
                    case ExpressionType.LessThan:
                    case ExpressionType.LessThanOrEqual:
                    case ExpressionType.Modulo:
                    case ExpressionType.Multiply:
                    case ExpressionType.NotEqual:
                    case ExpressionType.Or:
                    case ExpressionType.OrElse:
                    case ExpressionType.Power:
                    case ExpressionType.RightShift:
                    case ExpressionType.Subtract:
                        return VisitBinaryExpression((BinaryExpression)node);

                    case ExpressionType.Constant:
                        return VisitConstantExpression((ConstantExpression)node);

                    case ExpressionType.MemberAccess:
                        return VisitMemberExpression((MemberExpression)node);

                    case ExpressionType.Call:
                        return VisitMethodCallExpression((MethodCallExpression)node);

                    case ExpressionType.Convert:
                    case ExpressionType.Not:
                    case ExpressionType.Quote:
                        return VisitUnaryExpression((UnaryExpression)node);

                    default:
                        throw new NotSupportedException($"'{node}' is not supported in a 'Where' query expression");
                }
#pragma warning restore IDE0066 // Convert switch statement to expression
            }
            return node;
        }

        /// <summary>
        /// Process a binary expression
        /// </summary>
        /// <param name="node">The expression to visit</param>
        /// <returns>The visited expression</returns>
        internal Expression VisitBinaryExpression(BinaryExpression node)
        {
            if (IsEnumExpression(node, out UnaryExpression enumExpression, out ConstantExpression constant) && enumExpression != null && constant != null)
            {
                Type enumType = enumExpression.Operand.Type;
                string enumString = Enum.ToObject(enumType, constant.Value).ToString();
                Expression call = Expression.Call(enumExpression, toStringMethod);
                Visit(Expression.MakeBinary(node.NodeType, call, Expression.Constant(enumString)));
            }
            else if (node.NodeType == ExpressionType.Add && node.Left.Type == typeof(string) && node.Right.Type == typeof(string))
            {
                Visit(Expression.Call(concatMethod, new[] { node.Left, node.Right }));
            }
            else
            {
                var op = new BinaryOperatorNode(node.NodeType.ToBinaryOperatorKind());
                FilterExpression.Push(op);
                Visit(node.Left);
                Visit(node.Right);
                SetChildren(op);
            }

            return node;
        }

        /// <summary>
        /// Process a constant expression
        /// </summary>
        /// <param name="node">The expression to visit</param>
        /// <returns>The visited expression</returns>
        private Expression VisitConstantExpression(ConstantExpression node)
        {
            FilterExpression.Push(new ConstantNode(node.Value));
            return node;
        }

        /// <summary>
        /// Process a member expression
        /// </summary>
        /// <param name="node">The expression to visit</param>
        /// <returns>The visited expression</returns>
        private Expression VisitMemberExpression(MemberExpression node)
        {
            // Is the member the name of a member?
            var memberName = GetTableMemberName(node, ContractResolver);
            if (memberName != null)
            {
                FilterExpression.Push(new MemberAccessNode(null, memberName));
                return node;
            }

            // Is this member actually a function that looks like a property (e.g. string.Length)
            var key = new MemberInfoKey(node.Member);
            var methodName = InstanceProperties.GetMethodName(key);
            if (methodName != null)
            {
                var fnCallNode = new FunctionCallNode(methodName);
                FilterExpression.Push(fnCallNode);
                Visit(node.Expression);
                SetChildren(fnCallNode);
                return node;
            }

            // Otherwise we don't support it
            throw new NotSupportedException($"The member '{node.Member.Name} is not supported in the 'Where' clause");
        }

        /// <summary>
        /// Process method calls for OData
        /// </summary>
        /// <param name="node">The node to visit</param>
        /// <returns>The visited node</returns>
        internal Expression VisitMethodCallExpression(MethodCallExpression node)
        {
            var baseDefinition = node.Method.GetRuntimeBaseDefinition();
            //
            // string.StartsWith(string, StringComparison)
            //
            if (baseDefinition.Equals(startsWithMethod) && node.Arguments.Count == 2 && node.Arguments[1].Type == typeof(StringComparison))
            {
                var callNode = new FunctionCallNode("startswith");
                FilterExpression.Push(callNode);
                VisitStringComparisonExpression(callNode, node);
                return node;
            }
            //
            // string.EndsWith(string, StringComparison)
            //
            if (baseDefinition.Equals(endsWithMethod) && node.Arguments.Count == 2 && node.Arguments[1].Type == typeof(StringComparison))
            {
                var callNode = new FunctionCallNode("endswith");
                FilterExpression.Push(callNode);
                VisitStringComparisonExpression(callNode, node);
                return node;
            }
            //
            // string.Equals(string)
            //
            if (baseDefinition.Equals(equals1Method) && node.Arguments.Count == 1)
            {
                var equalityNode = new BinaryOperatorNode(BinaryOperatorKind.Equal);
                FilterExpression.Push(equalityNode);
                Visit(node.Object);
                Visit(node.Arguments[0]);
                SetChildren(equalityNode);
                return node;
            }
            //
            // string.Equals(string, StringComparison)
            //
            if (baseDefinition.Equals(equals2Method) && node.Arguments.Count == 2 && node.Arguments[1].Type == typeof(StringComparison))
            {
                var equalityNode = new BinaryOperatorNode(BinaryOperatorKind.Equal);
                FilterExpression.Push(equalityNode);
                VisitStringComparisonExpression(equalityNode, node);
                return node;
            }
            //
            // Anything in the MethodNames table (which has a direct relationship to the OData representation)
            //
            var key = new MemberInfoKey(node.Method);
            if (MethodNames.TryGetValue(key, out string methodName, out bool isStatic))
            {
                var fnCallNode = new FunctionCallNode(methodName);
                FilterExpression.Push(fnCallNode);
                foreach (var argument in (isStatic ? Array.Empty<Expression>() : new Expression[] { node.Object }).Concat(node.Arguments))
                {
                    Visit(argument);
                }
                SetChildren(fnCallNode);
                return node;
            }
            //
            // string.ToString()
            //
            if (baseDefinition.Equals(toStringMethod))
            {
                Visit(node.Object);
                return node;
            }
            //         
            // Default case
            //
            throw new NotSupportedException($"'{node}' is not supported in a 'Where' clause");
        }

        /// <summary>
        /// Process a two-argument string-expression (startsWith, endsWith)
        /// </summary>
        /// <param name="node">The node to visit</param>
        /// <returns>The visited node</returns>
        internal Expression VisitStringComparisonExpression(QueryNode queryNode, MethodCallExpression node)
        {
            StringComparison comparison = GetStringComparisonFromExpression(node.Arguments[1]);
            switch (comparison)
            {
                case StringComparison.Ordinal:
                case StringComparison.InvariantCulture:
                    Visit(node.Object);
                    Visit(node.Arguments[0]);
                    SetChildren(queryNode);
                    return node;

                case StringComparison.OrdinalIgnoreCase:
                case StringComparison.InvariantCultureIgnoreCase:
                    var arg1 = new FunctionCallNode("tolower");
                    FilterExpression.Push(arg1);
                    Visit(node.Object);
                    SetChildren(arg1);

                    var arg2 = new FunctionCallNode("tolower");
                    FilterExpression.Push(arg2);
                    Visit(node.Arguments[0]);
                    SetChildren(arg2);

                    SetChildren(queryNode);
                    return node;

                default:
                    throw new NotSupportedException($"'{node}' is not using a supported StringComparison value");
            }
        }

        /// <summary>
        /// When there is a StringComparison node, find it's value.  The backend doesn't
        /// support StringComparison, so remove it from the stack.
        /// </summary>
        /// <param name="node">The expression.</param>
        /// <returns>The StringComparison value.</returns>
        internal StringComparison GetStringComparisonFromExpression(Expression node)
        {
            // Get the StringComparison argument by visiting the node.
            // Don't leave it on the stack!
            Visit(node);
            QueryNode comparisonNode = FilterExpression.Pop();

            // We expect it to be a constant node of type StringComparison
            if (comparisonNode is not ConstantNode ccn || ccn.Value.GetType() != typeof(StringComparison))
            {
                throw new NotSupportedException($"'{node}' must have a constant StringComparison value");
            }

            // If it is, then return the value.
            return (StringComparison)ccn.Value;
        }

        /// <summary>
        /// Process unary expressions
        /// </summary>
        /// <param name="node">The node to visit</param>
        /// <returns>The visited node</returns>
        internal Expression VisitUnaryExpression(UnaryExpression node)
        {
            switch (node.NodeType)
            {
                case ExpressionType.Not:
                    Visit(node.Operand);
                    FilterExpression.Push(new UnaryOperatorNode(UnaryOperatorKind.Not, FilterExpression.Pop()));
                    break;
                case ExpressionType.Quote:
                    Visit(node.Operand);
                    break;
                case ExpressionType.Convert:
                    if (!IsConversionImplicit(node, node.Operand.Type, node.Type))
                    {
                        throw new NotSupportedException($"Implicit conversion from '{node.Operand.Type}' to '{node.Type}' is not supported by a 'Where' {node.NodeType}' clause.");
                    }
                    Visit(node.Operand);
                    break;
                default:
                    throw new NotSupportedException($"The operator '{node.NodeType}' is not supported in a 'Where' clause");
            }
            return node;
        }

        /// <summary>
        /// Check whether a conversion from one type to another will be made implicitly by the datasync server.
        /// </summary>
        /// <param name="node">The conversion expression</param>
        /// <param name="from">The type to convert from</param>
        /// <param name="to">The type to convert to</param>
        /// <returns>True if there is an implicit conversion</returns>
        internal bool IsConversionImplicit(UnaryExpression node, Type from, Type to)
            => GetTableMemberName(node.Operand, ContractResolver) != null && ImplicitConversions.IsImplicitConversion(from, to);

        /// <summary>
        /// Checks if the provided binary expression is an enum.
        /// </summary>
        /// <param name="node">The binary expression to check</param>
        /// <param name="unaryExpression">The expression which is the enum.</param>
        /// <param name="constantExpression">The constant expression containing the enum value</param>
        /// <returns>Trye if an enum expression is found.</returns>
        internal static bool IsEnumExpression(BinaryExpression node, out UnaryExpression unaryExpression, out ConstantExpression constantExpression)
        {
            // Case 1: enum on the left side
            if (node.Left is UnaryExpression left && IsEnumExpression(left) && node.Right is ConstantExpression leftExpr)
            {
                unaryExpression = left;
                constantExpression = leftExpr;
                return true;
            }

            // Case 2: enum on the right side
            if (node.Right is UnaryExpression right && IsEnumExpression(right) && node.Left is ConstantExpression rightExpr)
            {
                unaryExpression = right;
                constantExpression = rightExpr;
                return true;
            }

            unaryExpression = null;
            constantExpression = null;
            return false;
        }

        /// <summary>
        /// Checks if the provided unary expression is an enum.
        /// </summary>
        /// <param name="expression">The expression to check</param>
        /// <returns>True if an enum.</returns>
        internal static bool IsEnumExpression(UnaryExpression expression)
            => expression.NodeType == ExpressionType.Convert && expression.Operand.Type.GetTypeInfo().IsEnum;

        /// <summary>
        /// Each <see cref="QueryNode"/> has a <see cref="QueryNode.SetChildren(IList{QueryNode})"/> method.  This
        /// copies the children from the filter expression stack into the query node.
        /// </summary>
        /// <param name="parent">The parent query node.</param>
        internal void SetChildren(QueryNode parent)
        {
            var args = new Stack<QueryNode>();
            while (FilterExpression.Peek() != parent)
            {
                args.Push(FilterExpression.Pop());
            }
            parent.SetChildren(args.ToList());
        }
    }
}
